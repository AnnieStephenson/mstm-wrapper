# Copyright 2011-2013, 2016 Vinothan N. Manoharan, Thomas G. Dimiduk,
# Rebecca W. Perry, Jerome Fung, Ryan McGorty, Anna Wang, Annie Stephenson, and
# Victoria Hwang
#
# This file is part of the mstm-wrapper project.
#
# This package is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This package is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this package.  If not, see <http://www.gnu.org/licenses/>.

"""
This package provides a python wrapper around the MSTM fortran-90 code
(http://www.eng.auburn.edu/~dmckwski/scatcodes/) written by Daniel Mackowski.
It produces input files, sends them to the mstm executable, parses the
output files, and calculates quantities of interest for static light scattering
measurements.  The mstm executable should be located in the user's path.

Based on work that was originally part of HoloPy
(https://github.com/manoharan-lab/holopy).

.. moduleauthor:: Anna Wang <annawang@seas.harvard.edu>
.. moduleauthor:: Annie Stephenson <stephenson@g.harvard.edu>
.. moduleauthor:: Victoria Hwang <vhwang@g.harvard.edu>
.. moduleauthor:: Vinothan N. Manoharan <vnm@seas.harvard.edu>
"""

from __future__ import division
import subprocess
import tempfile
import os
import shutil
import numpy as np
import pandas as pd
from scipy import interpolate
from scipy import integrate

def calc_scat_matrix(target, incident, theta, phi=None, delete=True,
                     mstm_executable='mstm'):
    """
    Calculate the first row of the mueller scattering matrix as a function of
    theta, phi, and wavelength.

    Parameters
    ----------
    target : an object of the Target class
    incident : an object of the Incident class
    theta : numpy array
        values for the polar scattering angle theta for scattering matrix
        computations, in degrees (must be 0-180)
    phi : numpy array (optional)
        values for the azimuth angle theta for scattering matrix computations,
        in degrees (must be 0-360); if phi is None, the calculation will
        average the scattering matrix over azimuthal angles
    delete : boolean
        True if the input and output files generated by the MSTM fortran code
        should be deleted after running
    mstm_executable : string
        name of mstm executable

    Returns
    -------
    numpy array:
        first row of scattering matrix
        corresponding theta
        corresponding phi
        corresponding wavelength
    """

    # put input files in a temp directory
    temp_dir = tempfile.mkdtemp()
    current_dir = os.getcwd()
    os.chdir(temp_dir)

    # get path to current module
    module_dir, _ = os.path.split(os.path.abspath(__file__))

    # Search for the executable in the user's path
    # (relies on shutils.which(), which works only in Python 3.3 and above)
    mstm_path = shutil.which(mstm_executable)
    if mstm_path is None:
        # search in the path to the current module
        mstm_path = shutil.which(mstm_executable, path=module_dir)
    if mstm_path is None:
        raise RuntimeError("MSTM executable" + " \'" + mstm_executable +
                           "\' " + "not found")

    # make angles file
    angle_filename = 'angles.dat'
    if phi is None:
        azimuth_average = True
        phi = np.array([0.0])
    else: 
        azimuth_average = False
    thetatot = np.repeat(theta, len(phi))
    phitot = np.tile(phi, len(theta))
    angles = np.vstack((thetatot, phitot))
    angles = angles.transpose()
    np.savetxt(os.path.join(temp_dir, angle_filename), angles, '%5.2f')

    # prepare input file for fortran code
    output_name = 'mstm_out.dat'
    if len(incident.wavevec)==1:
        wavevec_delta = 0
    if len(incident.wavevec)>1:
        wavevec_delta = incident.wavevec[1]-incident.wavevec[0]
    wavevec_start = incident.wavevec[0]
    wavevec_end = incident.wavevec[len(incident.wavevec)-1] +\
              wavevec_delta/2
    wavevec_info = [wavevec_start, wavevec_end, wavevec_delta]
    polarization_angle = np.arctan2(incident.jones_vec[1],
                                    incident.jones_vec[0])*180/np.pi
    parameters = (target.num_spheres, target.index_spheres,
                  target.index_matrix)

    # format sphere sizes and positions
    radii = target.radii
    x = target.x-np.mean(target.x)
    y = target.y-np.mean(target.y)
    z = target.z-np.mean(target.z)
    sphere_str = ''
    for k in range(target.num_spheres):
        sphere_str += '{0:.10e} {1:.10e} {2:.10e} {3:.10e}\n'.format(radii[k],
                                                                     x[k], y[k],
                                                                     z[k])
    # convert to Fortran scientific notation, which uses 'd' instead of 'e'
    sphere_str = sphere_str.replace('e', 'd')

    # make string substitutions to the template and write to the input file
    template_path = os.path.join(module_dir, 'input_template.txt')
    with open(template_path, 'r') as template_file:
        template = template_file.read()
    mstm_input = template.format(target = parameters,
                                 spheres = sphere_str,
                                 output_file = output_name,
                                 azimuth_average = int(azimuth_average),
                                 scattering_angle_file = angle_filename,
                                 number_scattering_angles = len(angles),
                                 length_scale_factor = wavevec_info)
    input_file = open(os.path.join(temp_dir, 'mstm.inp'), 'w')
    input_file.write(mstm_input)
    input_file.close()

    # run MSTM fortran executable
    cmd = [mstm_path, 'mstm.inp']
    subprocess.check_call(cmd, cwd=temp_dir)

    # Read scattering matrix from results file
    if azimuth_average is True:
        scat_mat_data = np.zeros([len(incident.wavevec), len(thetatot), 17])
    else:
        scat_mat_data = np.zeros([len(incident.wavevec), len(thetatot), 18])
    #result_file = glob.glob(os.path.join(temp_dir, 'mstm_out.dat'))[0]
    result_file = os.path.join(temp_dir, 'mstm_out.dat')
    with open(result_file, "r") as myfile:
        mstm_result = myfile.readlines()
    mstm_result = [line.replace('\n', '') for line in mstm_result]
    mstm_result = [line.replace('\t', '') for line in mstm_result]
    mstm_result = [line for line in mstm_result if line]
    scat_mat_el_row = [i for i, j in enumerate(mstm_result)
                       if j == ' scattering matrix elements']
    qsca_row = [i for i, j in enumerate(mstm_result)
                if j == ' unpolarized total ext, abs, scat efficiencies, w.r.t. xv, and asym. parm']

    if polarization_angle == 0:
        qsca_line_shift = 3
    else :
        qsca_line_shift = 5
    for m in range(len(scat_mat_el_row)):
        smdata = mstm_result[scat_mat_el_row[m] + 2 : scat_mat_el_row[m] + \
                             2 + len(angles)]
        qscanums = mstm_result[qsca_row[m]+ qsca_line_shift]
        qsca = qscanums.split(' ')
        qsca = [item for item in qsca if item]
        qsca = float(qsca[2])
        for i in range(len(angles)):
            a = smdata[i].split(' ')
            a = [item for item in a if item]
            smdata[i] = [float(j) for j in a]
            smdata[i] = np.array(smdata[i])*qsca/8
            smdata[i][0] = smdata[i][0]*8/qsca
            smdata[i][1] = smdata[i][1]*8/qsca
        scat_mat_data[m][:][:] = smdata

    # delete temp files
    os.chdir(current_dir)
    if delete:
        shutil.rmtree(temp_dir)

    return scat_mat_data

def calc_intensity(target, incident, theta, phi):
    """
    Calculate the intensity of light scattered from a structure as a function
    of theta, phi, and wavelength.

    Parameters
    ----------
    target : an object of the Target class
    incident : an object of the Incident class
    theta : numpy array
        values for the polar scattering angle theta for scattering matrix
        computations, in degrees (must be 0-180)
    phi : numpy array
        values for the azimuth angle theta for scattering matrix computations,
        in degrees (must be 0-360)

    Returns
    -------
    numpy array :
        a 3d numpy array whose first dimension is the number of wavelengths,
        2nd dimension is the number of angles, and 3rd dimension is the 3
        values needed to describe the data: theta, phi, and wavelength
    """
    scat_mat_data = calc_scat_matrix(target, incident, theta, phi)
    prefactor = 1.0/((target.index_matrix*incident.wavevec)**2)
    if phi is None:
        intensity_data = np.zeros([len(incident.wavevec),
                                   len(theta), 2])
        intensity_data[:,:,1] = prefactor[:,np.newaxis] * \
                                (scat_mat_data[:,:,1]*incident.stokes_vec[0] +
                                 scat_mat_data[:,:,2]*incident.stokes_vec[1] +
                                 scat_mat_data[:,:,3]*incident.stokes_vec[2] +
                                 scat_mat_data[:,:,4]*incident.stokes_vec[3])
    else:
        intensity_data = np.zeros([len(incident.wavevec),
                                   len(theta)*len(phi), 3])
        intensity_data[:,:,1] = scat_mat_data[:,:,1]
        intensity_data[:,:,2] = prefactor[:,np.newaxis] * \
                                (scat_mat_data[:,:,2]*incident.stokes_vec[0] +
                                 scat_mat_data[:,:,3]*incident.stokes_vec[1] +
                                 scat_mat_data[:,:,4]*incident.stokes_vec[2] +
                                 scat_mat_data[:,:,5]*incident.stokes_vec[3])
    intensity_data[:,:,0] = scat_mat_data[:,:,0]

    return intensity_data

def calc_cross_section(target, incident, theta, phi):
    """
    Calculate the cross section from wavelength. 
    If theta = 0-180 and phi = 0-360, the cross section calculated is the total
    cross section
    If theta = 90-180 and phi = 0-360, the cross section caclulated is the
    reflection cross section, which is proportional to the reflectivity

    Parameters
    ----------
    target: an object of the Target class
    incident: an object of the Incident class
    theta: numpy array
        values for the polar scattering angle theta for scattering matrix
        computations, in degrees (must be 0-180)
    phi: numpy array
        values for the azimuth angle theta for scattering matrix
        computations, in degrees (must be 0-360)

    Returns
    -------
    numpy array:
        cross_section
    """
    intensity_data = calc_intensity(target, incident, theta, phi)
    cross_section = np.zeros([len(incident.wavevec)])
    for i in np.arange(0, len(incident.wavevec), 1): # for each wl
        I_grid = intensity_data[i,:,2]*np.sin(intensity_data[i,:,0]*np.pi/180.)
        I_grid = I_grid.reshape(len(theta),len(phi))
        f = interpolate.interp2d(phi, theta, I_grid)
        [cross_section[i], err] = integrate.dblquad(f, theta[0]*np.pi/180,
            theta[len(theta)-1]*np.pi/180, lambda ph: phi[0]*np.pi/180, lambda ph: phi[len(phi)-1]*np.pi/180)
    return cross_section

class Target:
    """
    Class to contain data describing the sphere assemblies that scatter the light

    Attributes
    ----------
    x : array
        x-coordinates of spheres in assembly
    y : array
        y-coordinates of spheres in assembly
    z : array
        z-coordinates of spheres in assembly
    radii : array
        radii of spheres in assembly
    index_matrix : array
        refractive index of medium surrounding spheres
    index_spheres : array
        refractive index of spheres
    num_spheres : integer
        number of spheres in assembly

    Notes
    -----
    x, y, z, and radii must be in same units, and must also match units of
    wavelength of incident light, which is defined in Incident class
    """
    def __init__(self, x, y, z, radii, index_matrix, index_spheres, num_spheres):
        """
        Constructor for object of the Target class. 
        """
        self.x = x
        self.y = y
        self.z = z
        self.radii = radii
        self.index_matrix = index_matrix
        self.index_spheres = index_spheres
        self.num_spheres = num_spheres

class Incident:
    """
    Incident objects represent the incident light which is scattered from sphere assemblies.

    Attributes
    ----------
    jones_vec : array
        Jones vector of the incident light
    stokes_vec : array
        Stokes vector of the incident light
    wavevec : array
        2*pi/wavelength of the incident light

    Notes
    -----
    wavelength units must match those of x, y, z, and radii defined in the
    Target class
    """
    def __init__(self, jones_vec, stokes_vec, wavevec):
        """
        Constructor for Incident object
        """
        self.jones_vec = jones_vec # jones vector
        self.stokes_vec = stokes_vec # stokes vector
        self.wavevec = wavevec
